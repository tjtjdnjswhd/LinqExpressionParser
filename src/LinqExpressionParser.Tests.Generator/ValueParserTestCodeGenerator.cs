#nullable enable

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Helper = LinqExpressionParser.Tests.Generator.ValueParserTestCodeGeneratorHelper;

namespace LinqExpressionParser.Tests.Generator
{
    [Generator]
    public class ValueParserTestCodeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(post => post.AddSource("ValueParserPostGenerateCode.g.cs", Helper.PostGenerateCodes));

            IncrementalValuesProvider<TestCodeGenerateInfo> infoProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: $"{Helper.GeneratedCodeNamespace}.{Helper.TestClassAttributeName}",
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: (context, _) => GetGenerateInfo(context));

            IncrementalValuesProvider<(TestCodeGenerateInfo, Compilation)> provider = infoProvider.Combine(context.CompilationProvider);

            context.RegisterSourceOutput(provider, GenerateCode);
        }

        private TestCodeGenerateInfo GetGenerateInfo(GeneratorAttributeSyntaxContext context)
        {
            ClassDeclarationSyntax @class = (ClassDeclarationSyntax)context.TargetNode;
            AttributeData classAttribute = context.Attributes.First();
            string defaultAssertMethod = classAttribute.ConstructorArguments[1].Value!.ToString();

            SemanticModel semanticModel = context.SemanticModel;

            IEnumerable<TestDataInfo> testDataInfos = @class.ChildNodes()
                .OfType<MemberDeclarationSyntax>()
                .Select(m =>
                {
                    if (!IsTestData(m, semanticModel))
                    {
                        return null;
                    }

                    IEnumerable<AttributeSyntax> attributes = m.AttributeLists.SelectMany(a => a.Attributes);
                    if (attributes.Any(a => semanticModel.GetSymbolInfo(a).Symbol?.ContainingType.Name == Helper.IgnoreDataAttributeName))
                    {
                        return null;
                    }

                    AttributeSyntax? assertMethodAttribute = attributes.FirstOrDefault(a => semanticModel.GetSymbolInfo(a).Symbol?.ContainingType.Name == Helper.AssertMethodAttributeName);
                    string assertMethod = assertMethodAttribute is null ? defaultAssertMethod : semanticModel.GetConstantValue(assertMethodAttribute.ArgumentList!.Arguments.First().Expression).ToString();
                    string identifierName = GetIdentifierText(m);
                    TestDataInfo dataInfo = new(identifierName, assertMethod);
                    return dataInfo;
                })
                .Where(t => t is not null)!;

            string testMethod = classAttribute.ConstructorArguments[0].Value!.ToString();
            return new TestCodeGenerateInfo(@class, testMethod, testDataInfos);
        }

        private void GenerateCode(SourceProductionContext context, (TestCodeGenerateInfo, Compilation) source)
        {
            (TestCodeGenerateInfo info, Compilation compilation) = source;

            ClassDeclarationSyntax testClassSyntax = info.TestClassSyntax;
            SemanticModel semanticModel = compilation.GetSemanticModel(testClassSyntax.SyntaxTree);

            SyntaxList<UsingDirectiveSyntax> allUsings = SyntaxFactory.List<UsingDirectiveSyntax>();
            foreach (var parent in testClassSyntax.Ancestors(false))
            {
                allUsings = parent switch
                {
                    NamespaceDeclarationSyntax n => allUsings.AddRange(n.Usings),
                    CompilationUnitSyntax c => allUsings.AddRange(c.Usings),
                    _ => allUsings
                };
            }

            INamedTypeSymbol classTypeSymbol = semanticModel.GetDeclaredSymbol(testClassSyntax)!;
            StringBuilder sb = new(1024);
            sb.Append(
                $$"""
                // <auto-generated/>
                {{allUsings}}

                namespace {{classTypeSymbol.ContainingNamespace.ToDisplayString()}}
                {
                    {{testClassSyntax.Modifiers}} class {{classTypeSymbol.Name}}
                    {
                        [TestMethod]
                        public Task {{info.TestMethodName}}()
                        {
                            return Task.WhenAll(

                """);

            foreach (var dataInfo in info.TestDataInfos)
            {
                sb.AppendLine(
                    $$"""
                                    {{dataInfo.AssertMethod}}({{dataInfo.IdentifierName}}),
                    """);
            };

            sb.Remove(sb.Length - 3, 3);
            sb.AppendLine("\n            );");
            sb.AppendLine("        }\n    }\n}");

            context.AddSource($"{classTypeSymbol.Name}.g.cs", sb.ToString());
        }

        private string GetIdentifierText(MemberDeclarationSyntax member) => member switch
        {
            PropertyDeclarationSyntax p => p.Identifier.Text,
            FieldDeclarationSyntax f => ((VariableDeclaratorSyntax)f.Declaration.DescendantNodes().First(c => c is VariableDeclaratorSyntax)).Identifier.Text,
            _ => throw new Exception()
        };

        private bool IsTestData(MemberDeclarationSyntax member, SemanticModel semanticModel)
        {
            GenericNameSyntax? genericName = (GenericNameSyntax?)(member switch
            {
                PropertyDeclarationSyntax p => p.ChildNodes().FirstOrDefault(c => c is GenericNameSyntax),
                FieldDeclarationSyntax f => f.Declaration.ChildNodes().FirstOrDefault(c => c is GenericNameSyntax),
                _ => null
            });

            if (genericName is null)
            {
                return false;
            }

            ISymbol? dataTypeSymbol = semanticModel.GetSymbolInfo(genericName).Symbol;
            return dataTypeSymbol?.Name == Helper.TestDataClassName;
        }
    }
}